# OPENCVE DOCKER COMPOSE

---
# Name of the Docker Compose project (optional)
name: opencve

# Reusable configuration block for common Airflow services
x-airflow-common: &airflow-common
  build:
    # Specifies the context directory to build the Docker image from (in this case, the scheduler directory)
    context: ../scheduler
    dockerfile: Dockerfile  # The Dockerfile to use for building the Airflow image
  env_file:
    - .env  # Environment variables are loaded from this file
  volumes:
    - ../scheduler/dags/:/opt/airflow/dags  # DAGs directory for Airflow
    - ../scheduler/airflow.cfg:/opt/airflow/airflow.cfg:ro  # Airflow config file, mounted as read-only
    - repositories:/home/airflow/repositories/  # Volume for storing repositories (data persistence)
  depends_on:  # Specify service dependencies, meaning these services must be healthy before starting
    &airflow-common-depends-on
    redis:
      condition: service_healthy  # Wait for Redis to be healthy
    postgres:
      condition: service_healthy  # Wait for PostgreSQL to be healthy

# Services defined below are the various components required for OpenCVE
services:
  # Airflow web server service
  airflow-webserver:
    <<: *airflow-common  # Inherit the common Airflow configuration
    container_name: airflow-webserver  # Name of the container
    command: webserver  # Command to run inside the container
    ports:
      - "${AIRFLOW_WEBSERVER_PORT:-8080}:8080"  # Expose the webserver port (default: 8080)
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:8080/health"]  # Health check using curl to verify webserver health
      interval: 60s  # How often to run the health check
      timeout: 30s  # How long to wait before the health check times out
      retries: 5  # Number of retries before considering the container unhealthy
      start_period: 30s  # Grace period before starting health checks
    restart: on-failure  # Restart the container on failure
    depends_on:
      airflow-init:  # Depend on the airflow-init service
        condition: service_completed_successfully  # Wait for it to complete successfully

  # Airflow scheduler service
  airflow-scheduler:
    <<: *airflow-common  # Inherit the common Airflow configuration
    container_name: airflow-scheduler  # Name of the container
    command: scheduler  # Command to run the scheduler
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:8974/health"]  # Health check for the scheduler
      interval: 60s
      timeout: 30s
      retries: 5
      start_period: 30s
    restart: on-failure
    depends_on:
      airflow-init:
        condition: service_completed_successfully

  # Airflow worker service
  airflow-worker:
    <<: *airflow-common
    container_name: airflow-worker
    command: celery worker  # Run the worker with Celery
    healthcheck:
      test:
        - "CMD-SHELL"
        - 'celery --app airflow.providers.celery.executors.celery_executor.app inspect ping -d "celery@$${HOSTNAME}" || celery --app airflow.executors.celery_executor.app inspect ping -d "celery@$${HOSTNAME}"'  # Ensure Celery is working
      interval: 60s
      timeout: 30s
      retries: 5
      start_period: 30s
    environment:
      DUMB_INIT_SETSID: "0"  # Prevent issues with Celery workers not handling signals properly
    restart: on-failure
    depends_on:
      airflow-init:
        condition: service_completed_successfully

  # Airflow initialization service
  airflow-init:
    <<: *airflow-common
    container_name: airflow-init
    entrypoint: /bin/bash  # Start bash
    command:
      - -c
      - exec /entrypoint airflow version  # Check Airflow version to ensure the image is set up
    environment:
      _AIRFLOW_DB_MIGRATE: 'true'  # Environment variable to enable database migration
      _AIRFLOW_WWW_USER_CREATE: 'true'  # Automatically create an admin user for the web UI
      _AIRFLOW_WWW_USER_USERNAME: ${_AIRFLOW_WWW_USER_USERNAME:-airflow}  # Admin username
      _AIRFLOW_WWW_USER_PASSWORD: ${_AIRFLOW_WWW_USER_PASSWORD:-airflow}  # Admin password
    user: "0:0"  # Run as root user (user id 0, group id 0)

  # OpenCVE web server service
  webserver:
    container_name: webserver
    env_file:
      - .env  # Load environment variables from .env file
    build:
      context: ../web/  # Context for building the webserver image
      args:
        - OPENCVE_REPOSITORY=${OPENCVE_REPOSITORY}  # Argument for the repository
        - OPENCVE_VERSION=${OPENCVE_VERSION}  # Argument for the version of OpenCVE
        - GUNICORN_CMD_ARGS=${GUNICORN_CMD_ARGS}  # Argument for Gunicorn settings
      dockerfile: Dockerfile  # Dockerfile to use for the build
    volumes:
      - ../web/opencve/conf/.env:/app/opencve/web/opencve/conf/.env:ro  # .env file for the webserver, mounted read-only
      - ../web/opencve/conf/settings.py:/app/opencve/web/opencve/conf/settings.py:ro  # Django settings file, mounted read-only
      - repositories:/app/repositories/:ro  # Repositories, mounted read-only
      - staticfiles:/app/static/  # Static files for the web server
    restart: on-failure  # Restart the web server on failure

  # Nginx reverse proxy service
  nginx:
    container_name: nginx
    image: nginx:bookworm  # Nginx image version
    ports:
       - "${OPENCVE_PORT:-80}:80"  # Expose port 80 for the web interface
    volumes:
      - ./conf/opencve.conf.template:/etc/nginx/conf.d/default.conf:ro  # Nginx configuration file, mounted read-only
      - staticfiles:/var/www/opencve/static/:ro  # Static files, mounted read-only
    restart: on-failure  # Restart Nginx on failure

  # Redis service for caching and message brokering
  redis:
    container_name: redis
    image: redis/redis-stack:latest  # Use the latest Redis image
    healthcheck:
       test: ["CMD", "redis-cli", "ping"]  # Health check to ensure Redis is responsive
       interval: 10s  # Check Redis every 10 seconds
       retries: 5  # Retry 5 times before considering Redis unhealthy
       start_period: 5s  # Grace period before starting health checks
    restart: on-failure  # Restart Redis on failure

  # PostgreSQL database service
  postgres:
    container_name: postgres
    image: postgres:${POSTGRES_VERSION:-15}  # Use PostgreSQL version 15 (default)
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-opencve}  # Set the default user to "opencve"
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-opencve}  # Set the default password
      POSTGRES_DB: opencve  # Database name
      PGDATA: /var/lib/postgreqsql/data  # Data directory for PostgreSQL
    restart: on-failure  # Restart on failure
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "$POSTGRES_USER"]  # Health check to ensure PostgreSQL is ready
      interval: 10s
      retries: 5
      start_period: 5s
    volumes:
      - ./db:/docker-entrypoint-initdb.d  # Mount initial database setup scripts
      - postgres-db:/var/lib/postgreqsql/data  # Volume for persisting the database data

# Define volumes for data persistence
volumes:
    postgres-db:  # Volume for PostgreSQL data
    staticfiles:  # Volume for static files used by the webserver
    repositories:  # Volume for storing repository data
